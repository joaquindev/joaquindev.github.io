---
layout: default
cover: false
title: Things and ideas to remember
---
<article class="post">
    <span class="blog-title">Things and ideas to remember</span>  
    <br/>
    <br/>
    <strong>Tests unitarios y su diferencia con los tests funcionales</strong>
    <small><a href="http://chimera.labs.oreilly.com/books/1234000000754/ch03.html#_unit_tests_and_how_they_differ_from_functional_tests">http://chimera.labs.oreilly.com/books/1234000000754/ch03.html#_unit_tests_and_how_they_differ_from_functional_tests</a></small>
    <span>
    <br/>
    A menudo la línea que separa los tests es un poco confusa. La diferencia principal es que los test funcionales van a comprobar la aplicación desde fuera o desde el punto de vista del usuario, mientras que los tests o pruebas unitarias van a comprobar la aplicación desde dentro, desde el punto de vista del programador. Entonces, seguiremos estos pasos: 1) Empezamos escribiendo un test funcional que va a describir la funcionalidad desde el punto de vista del usuario. 2) Lógicamente como no tenemos nada de código, este test funcional va a fallar. Empezaremos a pensar qué es lo que tenemos que tener para que no falle (pero acordaros de pensar en bajo nivel, es decir, no nos vale pensar que para que no falle <italic>la aplicación tendría que estar hecha</italic> sino que tenemos que pensar qué escribir para que no falle en el estado actual. Entonces ahora tendremos uno o varios tests unitarios que definen cómo queremos se comporte nuestro código. La idea es que cada linea de producción o por lo menos cada bloque lógico esté comprobado por uno de nuestros test unitarios. 3) Una vez que enunciamos o definimos los tests unitarios, éstos fallarán porque no hay código escrito. Ahora toca escribir la menor cantidad de código posible de la aplicación para que los tests unitarios no fallen. Podremos iterar entre los pasos 2 y 3 varias veces hasta que los tests o pruebas unitarias no fallen. 4) Ahora podemos volver a ejecutar nuestras pruebas funcionales y ver si pasan o si hay que escribir algo más. Así puede que ahora nos demos cuenta que tenemos que escribir algún test unitario más. 
    </span>
    <hr/>
    <br/>
    <strong>Semantic versioning</strong>
    <small><a href="http://semver.org">Semver.og </a></small>
    <span>
    <br/>
"connect": "1.8.7". The 1 indicates the Major version, the 8 indicates the Minor version and the 7 is the Patch level. You don't have to specify the exact version number in your package.json. We don't exactly have to put our exact version number, we can use ranges, for instance: "connect": "~1" that means npm will work as long as the version is >=1.0.0 <2.0.0, this is dangerous because any changes to the Minor version could break your App. We can make it a little safer by doing this: "connect":"~1.8" that npm will install anything that >=1.8 <2.0.0, but we could have problems because for instance there are usually name changes in API from Minor to Minor versions. The safest way to define a range is: "connect":"~1.8.7". This means Npm will install only the patches which means: >=1.8.7 <1.9.0 It shouldn't break your application.
    </span>
    <hr/>
    <strong>topic of the idea or text to remember</strong>
    <small><a href="">link text </a></small>
    <span>
    <br/>
    text and ideas to remember
    </span>
    <hr/>
</article>

